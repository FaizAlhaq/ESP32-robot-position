#include <Arduino.h>
#include <analogWrite.h>

// Pin definisi
#define TRIG_PIN_HC_SR04_left 13
#define ECHO_PIN_HC_SR04_left 14
#define TRIG_PIN_HC_SR04_right 25
#define ECHO_PIN_HC_SR04_right 26

// Variabel Kalman Filter
float Q = 0.0887; // Process noise covariance
float R = 0.8866; // Measurement noise covariance
float P = 1;      // Estimation error covariance

float left = 0;
float right = 0;

// Semaphore untuk sinkronisasi
SemaphoreHandle_t xSemaphore;

float measureDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH);
  return (duration / 2.0) * 0.0343; // Konversi ke cm
}

float kalmanFilter(float measurement, float &P, float Q, float R, float &x) {
  P = P + Q;
  float K = P / (P + R);
  x = x + K * (measurement - x);
  P = (1 - K) * P;
  return x;
}

void setup() {
  pinMode(TRIG_PIN_HC_SR04_left, OUTPUT);
  pinMode(ECHO_PIN_HC_SR04_left, INPUT);

  pinMode(TRIG_PIN_HC_SR04_right, OUTPUT);
  pinMode(ECHO_PIN_HC_SR04_right, INPUT);

  // Membuat semaphore binary
  xSemaphore = xSemaphoreCreateBinary();

  // Berikan semaphore pertama kali untuk sensor kiri
  xSemaphoreGive(xSemaphore);

  // Membuat task
  xTaskCreatePinnedToCore(left_sensor, "left_sensor", 2048, NULL, 5, NULL, 0);
  xTaskCreatePinnedToCore(right_sensor, "right_sensor", 2048, NULL, 4, NULL, 0);
  xTaskCreatePinnedToCore(print_GUI, "print_GUI", 2048, NULL, 3, NULL, 0);
  xTaskCreatePinnedToCore(access_motor, "access_motor", 2048, NULL, 2, NULL, 0);

  Serial.begin(9600);
}

void left_sensor(void *pvParameters) {
  static float x_left = 0;
  static float P_left = P;
  while (1) {
    if (xSemaphoreTake(xSemaphore, portMAX_DELAY) == pdTRUE) {
      float measured_distance = measureDistance(TRIG_PIN_HC_SR04_left, ECHO_PIN_HC_SR04_left);
      float actual_distance = (0.961 * measured_distance) + 0.927;
      left = kalmanFilter(actual_distance, P_left, Q, R, x_left);
      Serial.println("left : " + String(left));
      xSemaphoreGive(xSemaphore);
    }
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}

void right_sensor(void *pvParameters) {
  static float x_right = 0;
  static float P_right = P;
  while (1) { 
    if (xSemaphoreTake(xSemaphore, portMAX_DELAY) == pdTRUE) {
      float measured_distance = measureDistance(TRIG_PIN_HC_SR04_right, ECHO_PIN_HC_SR04_right);
      float actual_distance = (0.961 * measured_distance) + 0.927;
      right = kalmanFilter(actual_distance, P_right, Q, R, x_right);
      Serial.println("right : " + String(right));
      xSemaphoreGive(xSemaphore);
    }
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}

void print_GUI(void *pvParameters) {
  while (1) {
    Serial.println(String(left) + "," + String(right));
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}

void access_motor(void *pvParameters) {
  const float DEAD_ZONE = 1.0;     // Zona mati di sekitar tengah
  const int MAX_SPEED = 80;       // Kecepatan maksimum motor (0 - 255)
  const float Kp = 5.0;            // Gain proporsi   onal (untuk kontrol sederhana)

  while (1) {
    float error = right - left;    // Hitung error posisi
    int speed = 0;

    // Terapkan zona mati
    if (error > DEAD_ZONE) {  
      // Bergerak ke kanan
      speed = min((int)(Kp * error), MAX_SPEED);
      analogWrite(16, 0);
      analogWrite(17, speed);
      Serial.println("Motor bergerak ke kanan dengan kecepatan: " + String(speed));
    } 
    else if (error < -DEAD_ZONE) { 
      // Bergerak ke kiri
      speed = min((int)(Kp * abs(error)), MAX_SPEED);
      analogWrite(16, speed);
      analogWrite(17, 0);
      Serial.println("Motor bergerak ke kiri dengan kecepatan: " + String(speed));
    } 
    else { 
      // Dalam zona mati: motor berhenti
      analogWrite(16, 0);
      analogWrite(17, 0);
      Serial.println("Motor berhenti (diam)");
    }

    vTaskDelay(20 / portTICK_PERIOD_MS);  // Delay agar lebih stabil
  }
}


void loop() { }

